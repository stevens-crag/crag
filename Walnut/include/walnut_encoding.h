#pragma once

#ifndef CRAG_WALNUT_ENCODING_H
#define CRAG_WALNUT_ENCODING_H

#include <boost/random/uniform_int_distribution.hpp>
#include <vector>

#include "Word.h"
#include "random_subset.h"

namespace crag {
namespace walnut {

using msg_hash_t = std::vector<uint8_t>;

//! Returns i-th (for i = 1 ... n-1) free generator of a pure braid subgroup generated by
//! g_{n-1, n} = b_{n-1}^2
//! g_{n-2, n} = b_{n-1} b_{n-2}^2 b_{n-1}^{-1}
//! ...
//! g_{1, n} = b_{n-1} b_{n-2} ... b_{2} b_{1}^2 b_{2}^{-1} b_{3}^{-1} ... b_{n-1}^{-1}
Word getFreePureBraidSubgroupGen(size_t n, size_t i);

bool areValidEncodingIndices(size_t n, const std::vector<size_t>& encoding_indices);

template <typename T, typename URNG>
std::vector<T> randomVector(size_t length, URNG& g) {
  std::vector<T> items(length, T(0));

  boost::random::uniform_int_distribution<T> distribution;

  for (size_t i = 0; i < length; ++i) {
    items[i] = distribution(g);
  }

  return items;
}

//! Returns a random n-bit string.
template <typename URNG>
msg_hash_t randomMessageHash(size_t n, URNG& g) {
  assert(n % 8 == 0);
  return randomVector<uint8_t>(n / 8, g);
}

//! Returns a random n-bit string using provided seed for a random numbers generator.
msg_hash_t randomMessageHash(size_t n, size_t seed);

//! Encodes a single byte for Walnut.
//! Returns a word in generators 1, 2, 3, 4.
Word encode(uint8_t b);

//! Message hash encoding in Walnut.
//! A message hash is represented as a bit string of length 8k,
//! which is actually a hash (SHA-1, SHA-2, MD5 ...) value of the original text message.
//! Returns a word in generators 1, 2, 3, 4.
Word encode(const msg_hash_t& msg_hash);

//! Encodes message hash in Walnut and replaces generators 1,...,4 with pure braids with specific indices.
Word encode(size_t n, const msg_hash_t& msg_hash, const std::vector<size_t>& encoding_indices);

//! Message hash encoder from Walnut specification
class DefaultEncoder {
public:
  DefaultEncoder(size_t n, std::vector<size_t> encoding_indices, size_t hash_size);

  const std::vector<size_t>& encodingIndices() const;

  Word operator()(const msg_hash_t& msg_hash) const;

  size_t hashSize() const;

private:
  std::vector<size_t> encoding_indices_;
  std::vector<Word> free_sugroup_gens_;
  size_t hash_size_;

  static std::vector<Word> getFreeSubgroupGens_(size_t n, const std::vector<size_t>& encoding_indices);
};

template <typename URNG>
DefaultEncoder randomEncoder(size_t n, size_t hash_size, URNG& g) {
  auto indices = random::subsetVector<size_t>(4, 1, n - 1, g);
  return DefaultEncoder(n, std::move(indices), hash_size);
}

DefaultEncoder randomEncoder(size_t n, size_t hash_size, size_t seed);

//! Encoder suggested in
//! https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/round-1/official-comments/WalnutDSA-official-comment.pdf
//! in the message on Friday, February 02, 2018 1:33 PM
class AdvancedEncoder {
public:
  AdvancedEncoder(size_t n, size_t hash_size, const std::vector<std::vector<size_t>>& generator_indices);

  Word operator()(const msg_hash_t& msg_hash) const;

  size_t hashSize() const;

private:
  // k x 4 matrix of free subgroup generators of the forms g_{i, n}
  std::vector<std::vector<Word>> gen_matrix_;
  size_t hash_size_;

  std::vector<std::vector<Word>>
  getFreeGenerators_(size_t n, const std::vector<std::vector<size_t>>& generator_indices) const;

  std::vector<size_t> encode(uint8_t b) const;
};

template <typename URNG>
AdvancedEncoder randomAdvancedEncoder(size_t n, size_t k, size_t hash_size, URNG& g) {
  std::vector<std::vector<size_t>> indices;
  indices.reserve(k);

  for (size_t i = 0; i < k; ++i) {
    indices.push_back(random::subsetVector<size_t>(4, 1, n - 1, g));
  }

  return AdvancedEncoder(n, hash_size, indices);
}

AdvancedEncoder randomAdvancedEncoder(size_t n, size_t k, size_t hash_size, size_t seed);
} // namespace walnut
} // namespace crag

#endif // CRAG_WALNUT_ENCODING_H
